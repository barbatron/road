// Generated by CoffeeScript 1.6.2
(function() {
  var r, req, root;

  root = this;

  req = {
    0: ['paper', 'tools', 'entities'],
    1: ['raphael'],
    2: ['layers']
  };

  r = requirejs;

  r(req[0], function() {
    var Line, Point, V;

    Point = (function() {
      function Point(x, y) {
        this.x = x;
        this.y = y;
      }

      Point.prototype.normalized = function() {
        var v;

        v = new Point(this.x, this.y);
        v.normalize();
        return v;
      };

      Point.prototype.normalize = function() {
        var length;

        length = this.length();
        this.x /= length;
        return this.y /= length;
      };

      Point.prototype.dot = function(p) {
        return this.x * p.x + this.y * p.y;
      };

      Point.prototype.cross = function(p) {
        return this.x * p.y - this.y * p.x;
      };

      Point.prototype.angle = function(p) {
        var theta;

        theta = this.dot(p) / (this.length() * p.length());
        return Math.acos(theta);
      };

      Point.prototype.pa = function() {
        if (this.pap == null) {
          this.pap = new paper.Point(this.x, this.y);
        }
        return this.pap;
      };

      Point.prototype.mirror = function(line) {
        var p, papLine;

        papLine = new paper.Path.Line(line.p0.pa(), line.p1.pa());
        if (line.p0 === line.p1) {
          console.log("line", line);
          console.log("papline", papLine);
        }
        p = papLine.getNearestPoint(this.pa());
        layers.tool.clear();
        layers.tool.drawDot(p, "#000");
        return P(p.x + (p.x - this.x), p.y + (p.y - this.y));
      };

      Point.prototype.signedAngle = function(p) {
        return Math.atan2(this.perp().dot(p), this.dot(p));
      };

      Point.prototype.length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      };

      Point.prototype.setLength = function(length) {
        this.normalize();
        this.x *= length;
        return this.y *= length;
      };

      Point.prototype.perp = function() {
        return new Point(-this.y, this.x);
      };

      Point.prototype.add = function(other) {
        return new Point(this.x + other.x, this.y + other.y);
      };

      Point.prototype.sub = function(other) {
        return new Point(this.x - other.x, this.y - other.y);
      };

      Point.prototype.sub = function(other) {
        return new Point(this.x - other.x, this.y - other.y);
      };

      Point.prototype.mult = function(value) {
        return new Point(this.x * value, this.y * value);
      };

      Point.prototype.div = function(value) {
        return new Point(this.x / value, this.y / value);
      };

      Point.prototype.distance = function(p1) {
        var p2, v;

        p2 = this;
        v = p1.sub(p2);
        return v.length();
      };

      return Point;

    })();
    root.P = function(x, y) {
      var p;

      if (y != null) {
        p = new Point(x, y);
      } else if (x.y != null) {
        p = new Point(x.x, x.y);
      } else {
        p = new Point(x.offsetX, x.offsetY);
      }
      return p;
    };
    V = function(len, ang) {
      var pp;

      pp = new paper.Point({
        length: len,
        angle: ang
      });
      return new Point(pp.x, pp.y);
    };
    Line = (function() {
      function Line(p0, p1) {
        this.p0 = p0;
        this.p1 = p1;
      }

      Line.prototype.slope = function() {
        return (this.p1.y - this.p0.y) / (this.p1.x - this.p0.x);
      };

      Line.prototype.inverse = function() {
        return L(this.p0, this.p1);
      };

      Line.prototype.toAbc = function() {
        var a, b, c;

        a = this.p1.y - this.p0.y;
        b = this.p0.x - this.p1.x;
        c = a * this.p0.x + b * this.p0.y;
        return {
          a: a,
          b: b,
          c: c
        };
      };

      Line.prototype.intersect = function(other) {
        var denominator, i1, i2;

        i1 = this.toAbc();
        i2 = other.toAbc();
        denominator = i1.a * i2.b - i2.a * i1.b;
        if (denominator !== 0) {
          return new Vertex2((i2.b * i1.c - i1.b * i2.c) / denominator, (i1.a * i2.c - i2.a * i1.c) / denominator);
        }
        return null;
      };

      Line.prototype.angle = function(other) {
        var a, b;

        a = this.getDirection();
        b = other.getDirection();
        return a.angle2(b);
      };

      Line.prototype.signedAngle = function(other) {
        var a, b;

        a = this.getDirection();
        b = other.getDirection();
        return a.signedAngle(b);
      };

      Line.prototype.length = function() {
        var x, y;

        x = this.p1.x - this.p0.x;
        y = this.p1.y - this.p0.y;
        return Math.sqrt(x * x + y * y);
      };

      Line.prototype.growAdd = function(amount) {
        var np1, v;

        v = this.getDirection();
        np1 = this.p1.add(v.mult(amount));
        return L(this.p0, np1);
      };

      Line.prototype.grow = function(factor) {
        var a, p1;

        a = (this.p1.sub(this.p0)).mult(factor);
        p1 = this.p0.add(a);
        return L(this.p0, p1);
      };

      Line.prototype.growAll = function(factor) {
        var a, p0, p1;

        a = (this.p1.sub(this.p0)).mult(factor);
        p1 = this.p0.add(a);
        p0 = this.p0.sub(a);
        return L(p0, p1);
      };

      Line.prototype.move = function(p) {
        var p0, p1;

        p0 = this.p0.add(p);
        p1 = this.p1.add(p);
        return L(p0, p1);
      };

      Line.prototype.getDirection = function() {
        var d;

        d = this.p1.sub(this.p0);
        return d.normalized();
      };

      Line.prototype.json = function() {
        return "" + this.p0.x + " " + this.p0.y + " - " + this.p1.x + " " + this.p1.y;
      };

      Line.prototype.perp = function(point) {
        var half, p0, p1, v;

        p0 = void 0;
        if (point) {
          p0 = point;
        } else {
          half = this.p1.sub(this.p0).div(2);
          p0 = this.p0.add(half);
        }
        v = this.getDirection();
        v = v.perp();
        p1 = p0.add(v);
        return new Line(p0, p1);
      };

      Line.prototype.distance = function(p1) {
        var a, b, c1, c2, d, l1, p, v, w;

        l1 = this;
        v = l1.p1.sub(l1.p0);
        w = p1.sub(l1.p0);
        c1 = w.dot(v);
        c2 = v.dot(v);
        b = c1 / c2;
        a = v.mult(b);
        p = l1.p0.add(a);
        d = p1.sub(p);
        return d.length();
      };

      Line.prototype.mult = function(f) {
        var p1;

        p1 = P(this.p1).sub(P(this.p0)).mult(f);
        return L(this.p0, p1);
      };

      Line.prototype.toCurve = function(factor) {
        var p1, p2;

        if (factor == null) {
          factor = 0.33333333;
        }
        p1 = L(this.p0, this.p1).grow(factor).p1;
        p2 = L(this.p1, this.p0).grow(factor).p1;
        return C({
          p0: this.p0,
          p1: p1,
          p2: p2,
          p3: this.p1
        });
      };

      return Line;

    })();
    root.L = function(p0, p1) {
      return new Line(p0, p1);
    };
    root.C = function(o) {
      var curve, end, handleIn, handleOut, start;

      if (o instanceof Line) {
        o = o.toCurve();
      }
      start = o.p0.pa();
      handleIn = o.p1.sub(o.p0).pa();
      handleOut = o.p2.sub(o.p3).pa();
      end = o.p3.pa();
      curve = new paper.Curve(start, handleIn, handleOut, end);
      curve.p0 = o.p0;
      curve.p1 = o.p1;
      curve.p2 = o.p2;
      curve.p3 = o.p3;
      return curve;
    };
    root.C.fromHandle = function(handle, end) {
      var etarg, mid, perp, sta, starg;

      sta = handle.node.pos;
      starg = L(handle.inverse.pos, handle.node.pos).growAdd(L(sta, end).length() / 3).p1;
      mid = handle.node.pos.add(end).div(2);
      perp = L(handle.node.pos, end).perp().growAll(1000);
      etarg = starg.mirror(perp);
      layers.tool.drawDot(starg, "#0F0");
      layers.tool.drawDot(mid, "#00F");
      layers.tool.drawLine(perp, "#0FF");
      layers.tool.drawDot(etarg, "#F0F");
      return C({
        p0: sta,
        p1: starg,
        p2: etarg,
        p3: end
      });
    };
    root.splitTest = function() {
      var c;

      return c = C({
        p0: P(0, 0),
        p1: P(0, 5),
        p2: P(10, 5),
        p3: P(10, 0)
      });
    };
    root.bezier = function(pts) {
      return function(t) {
        var a, b, i, j;

        a = pts;
        while (a.length > 1) {
          i = 0;
          b = [];
          j = void 0;
          while (i < a.length - 1) {
            b[i] = [];
            j = 0;
            while (j < a[i].length) {
              b[i][j] = a[i][j] * (1 - t) + a[i + 1][j] * t;
              j++;
            }
            i++;
          }
          a = b;
        }
        return a[0];
      };
    };
    root.split = function(o, t) {
      var drawCurve, left, right,
        _this = this;

      left = [];
      right = [];
      drawCurve = function(points, t) {
        var i, newpoints;

        if (points.length === 1) {
          left.push(points[0]);
          return right.push(points[0]);
        } else {
          newpoints = new Array(points.length - 1);
          i = 0;
          while (i < newpoints.length) {
            if (i === 0) {
              left.push(points[i]);
            }
            if (i === newpoints.length - 1) {
              right.push(points[i + 1]);
            }
            if (points[i + 1] != null) {
              newpoints[i] = points[i].mult(1 - t).add(points[i + 1].mult(t));
            }
            i++;
          }
          return drawCurve(newpoints, t);
        }
      };
      drawCurve([o.p0, o.p1, o.p2, o.p3], t);
      return {
        right: {
          p0: right[0],
          p1: right[1],
          p2: right[2],
          p3: right[3]
        },
        left: {
          p0: left[0],
          p1: left[2],
          p2: left[1],
          p3: left[3]
        }
      };
    };
    return root.curveLen = function(c) {
      var cur, curLoc, direction, dist, prev, tally;

      prev = c.getLocationAt(0.001, true).point;
      tally = 0;
      curLoc = 0;
      direction = 1;
      cur = null;
      while (curLoc < 1) {
        curLoc += 0.10 * direction;
        cur = c.getLocationAt(curLoc, true).point;
        dist = cur.getDistance(prev);
        layers.tool.drawDot(cur);
        tally += dist;
        prev = cur;
      }
      return tally;
    };
  });

}).call(this);

/*
//@ sourceMappingURL=geometry.map
*/
